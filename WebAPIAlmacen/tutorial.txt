Crear proyecto

Elegir plantilla de proyecto Webapi, dar un nombre al proyecto y dejar las opciones por defecto.
Eliminar el archivo WeatherForecast.cs y el controller WeatherForecastController

Crear la base de datos MiAlmacen con estos scripts
CREATE TABLE Familias (
  Id              INT           NOT NULL    IDENTITY    PRIMARY KEY,
  Nombre           NVARCHAR(100)  NOT NULL
);

CREATE TABLE Productos (
    Id              INT           NOT NULL    IDENTITY    PRIMARY KEY,
    Nombre        NVARCHAR (150) NOT NULL,
    Precio        DECIMAL (9, 2) NOT NULL,
    FechaAlta     DATE           NULL,
    Descatalogado BIT            NOT NULL,
    FotoURL       NVARCHAR (MAX) NULL,
    FamiliaId     INT            NOT NULL,
    CONSTRAINT FK_Familias_Productos FOREIGN KEY (FamiliaId) REFERENCES Familias (Id)
);

Agregar los paquetes necesarios a la aplicación desde Herramientas, Administrador de paquetes Nuget.
Instalar estos paquetes:
Microsoft.EntityFrameworkCore.SqlServer 
Microsoft.EntityFrameworkCore.Tools 

-----------------------------------------------------------------------------------------------------------
Crear los modelos mediante Scaffold
Ejecutar el siguiente comando desde la consola de paquetes Nuget
Scaffold-DbContext "Data Source=localhost;Initial Catalog=MiAlmacen;Integrated Security=True;TrustServerCertificate=true" -Provider Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models -force -project WebAPIAlmacen

Debemos sustituir el valor de Data Source por la configuración de nuestro servidor
Al ejecutarse el comando se crea la carpeta Models con los modelos de datos y MiAlmacenContext con la configuración y estructura de la base de datos
-----------------------------------------------------------------------------------------------------------
Crear controller de Familias

En el archivo appsettings.development.json ponemos la cadena de conexión de la base de datos
En el program registramos la conexión leyendo la cadena de conexión anterior y creando un context que pueda inyectarse
en otras clases, normalmente controllers y/o servicios
Creamos el controller de familias en la carpeta controller. Es MUY IMPORTANTE que cada controller tenga el sufijo controller
En cada controller, inyectamos como dependencia el context (MiAlmacenContext) para poder utilizar la base de datos
-----------------------------------------------------------------------------------------------------------
Desarrollar controller de Familias

Cada punto de acceso del controller:
    Es un método debe ir precedido de el tipo de petición (Get, Post, Put o Delete habitualmente)
    Debe ser asíncrono async Task y preferiblemete devolver un ActionResult para, además de la información, devolver el código de retorno,
    por ejemplo, un Ok 200 cuando va todo bien o un Bad Request 400 cuando hay algún fallo
    Al ser asíncrono, cada operación del context debe precederse por un await e incluir un método que contenga Async
    Cada uno de los puntos de acceso debe tener una ruta diferente (por ejemplo, no puede haber dos [HttpGet], el segundo incluiría una ruta)
    También puede haber argumentos. Estos argumentos son los que el punto de acceso necesitará para programar su lógica
    Estos argumentos van entre paréntesis junto al nombre del método y deben coincidir en su nombre con los argumentos expuestos en la ruta
    Por defecto, los argumentos se toman de la ruta ([FromRoute]). Si viene con sintaxis querystring van con [FromQuery] y si
    vienen con archivos con [FromForm]

    Opcionalmente, podemos tener en cuenta ajustar el tracking en la aplicación. Para ello, en el Program debemos deshabilitarlo
    y en los controladores, activar el tracking en las operaciones necesarias (modificaciones de datos)

------------------------------------------------------------------------------------------------------------
Servicios
Un servicio centraliza operaciones que de forma reiterada vamos a necesitar en el proyecto
Lo habitual es crear una carpeta Services e ir creando los servicios dentro
Cada servicio es una clase autónoma en cuyo constructor se registran las dependencias que necesita
Una vez desarrollado, se registra en el program. Después, en los controllers donde se usa se debe inyectar como
dependencia de la misma manera que lo hacemos con el context

------------------------------------------------------------------------------------------------------------
Servicios con interfaces

Como buena práctica, se pueden crear interfaces como especificaciones para los servicios. Si hacemos esto,
en el program el servicio se debe registrar a partir de la interface y en cada controller el servicio se debe
registrar haciendo referencia a la interface

------------------------------------------------------------------------------------------------------------
Servicios para tareas programadas
Estos servicios son Singleton porque solo se ejecuta una instancia de estos en el servidor. Para desarrollar
este tipo de servicios, estas clases deben heredar de IHostedService y en el program se deben registrar mediante
el método AddHostedService

Estos servicios se construyen siempre igual, siendo el método StartAsync el que se ejecuta de forma automática al
iniciarse el servicio y el StopAsync el que se ejecuta al finalizar el servicio. En ambos métodos programaríamos la
lógica del servicio

------------------------------------------------------------------------------------------------------------
Middlewares

Los Middlewares son procesos que se ejecutan uno tras otro tras llegar una petición al servidor. Los distinguimos en el program
por su prefijo use. Muchos tienen lógica ya predefinida y otros los podemos desarrollar nosotros.
Cuando necesitamos desarrollar uno, creamos una clase en una ubicación, habitualmente una carpeta Middlewares, inyectamos
como dependencia de la clase RequestDelegate e incluimos el método InvokeAsync. Este método ya viene con la información de la 
petición (HttpContext). Dentro del InvokeAsync programamos la lógica del Middleware. Podemos analizar, rechazar e incluso
transformar una petición. Si decidimos que la petición debe continuar, especificamos que debe proseguir con el siguiente
middleware (next(httpContext))

------------------------------------------------------------------------------------------------------------
Filtros

Los filtros son procesos que se ejecutan tras los middlewares. Pueden servir, por ejemplo, como filtros de autorización 
para examinar si un usuario puede acceder a determinados puntos de acceso. También nos pueden servir para controlar
de forma global excepciones. Este es el llamado filtro de excepción. Los filtros son clases que suelen ir en una carpeta Filters
El filtro de excepción es una clase que hereda de ExceptionFilterAttribute. El método OnException viene ya con la información de la excepción.
Será en este método donde programemos la respuesta común a todas las excepciones.
En el program, los filtros hay que registrarlos en el método AddControllers

------------------------------------------------------------------------------------------------------------
CORS

Para especificar una cors policy que controle a nivel general el tipo de peticiones que se aceptan y desde donde,
simplemente debemos especificar en el Program estas características y emplear el middleware UseCors

------------------------------------------------------------------------------------------------------------
Procedimientos almacenados

Incluir los siguientes procedimientos almacenados agregando consultas a la base de datos

CREATE PROCEDURE Familias_Insertar
                @nombre nvarchar(150),
                @id int OUTPUT
                AS
                BEGIN
                SET NOCOUNT ON;
                INSERT INTO Familias(Nombre)
                VALUES (@nombre);
                SELECT @id = SCOPE_IDENTITY();
                END


CREATE PROCEDURE Familias_ObtenerPorId
                @id int
                AS
                BEGIN
                SET NOCOUNT ON;
                SELECT *
                FROM Familias
                WHERE Id = @id;
                END

En FamiliasController abrimos puntos de acceso (un post y un get) para poder ejecutarlos




------------------------------------------------------------------------------------------------------------
SEGURIDAD

Creamos la tabla de usuarios y hacemos el Scaffold

CREATE TABLE [dbo].[Usuarios]
(
	[Id] INT NOT NULL PRIMARY KEY IDENTITY, 
    [Email] NVARCHAR(100) NOT NULL, 
    [Password] NVARCHAR(500) NOT NULL, 
    [Salt] VARBINARY(MAX) NULL
)

------------------------------------------------------------------------------------------------------------
Encriptación de doble vía

Ponemos una clave de encriptación en la configuración (appsettings)

  "ClaveEncriptacion": "123Curso2022321"

Creamos una clase DTOUsuario en la carpeta DTO para recibir la información en el controller de usuarios
Habilitamos en el Program la encriptación de doble vía:
builder.Services.AddDataProtection();

Ponemos los métodos de creación y autenticación de usuarios en el controller de Usuarios inyectando las dependencias necesarias

 public class UsuariosController : ControllerBase
    {

        private readonly MiAlmacenContext context;
        private readonly IConfiguration configuration;
        private readonly IDataProtector dataProtector;
        public UsuariosController(MiAlmacenContext context, IConfiguration configuration, IDataProtectionProvider dataProtectionProvider)
        {
            this.context = context;
            this.configuration = configuration;
            dataProtector = dataProtectionProvider.CreateProtector(configuration["ClaveEncriptacion"]);
        }

        [HttpPost("encriptar/nuevousuario")]
        public async Task<ActionResult> PostNuevoUsuario([FromBody] DTOUsuario usuario)
        {
            var passEncriptado = dataProtector.Protect(usuario.Password);
            var newUsuario = new Usuario
            {
                Email = usuario.Email,
                Password = passEncriptado
            };
            await context.Usuarios.AddAsync(newUsuario);
            await context.SaveChangesAsync();

            return Ok(newUsuario);
        }

        [HttpPost("encriptar/checkusuario")]
        public async Task<ActionResult> PostCheckUserPassEncriptado([FromBody] DTOUsuario usuario)
        {
            var usuarioDB = await context.Usuarios.FirstOrDefaultAsync(x => x.Email == usuario.Email);
            if (usuarioDB == null)
            {
                return Unauthorized();
            }

            var passDesencriptado = dataProtector.Unprotect(usuarioDB.Password);
            if (usuario.Password == passDesencriptado)
            {
                return Ok();
            }
            else
            {
                return Unauthorized();
            }
        }

    }

------------------------------------------------------------------------------------------------------------
Encriptación de una vía (hash)

En una clase ResultadoHash especificamos el tipo de información que utilizarán el controller de usuarios
y el servicio de encriptación.
La encriptación la vamos a incluir en un servicio para poder reutiizarla o incluso llevarla a otro proyecto.
El servicio es HashService

    public class HashService
    {
        // Un hash es una clave que no se puede revertir. Es lo correcto para contraseñas seguras
        // El hash es lo que se guardará en la tabla de usuarios.
        // Las funciones que generan hash también nos van a servir para contrastarlos
        // Un salt es un valor aleatorio que se anexa al texto plano al que queremos aplicar la función que genera el hash
        // Añade más seguridad porque, uniendo un salt aleatorio al password, los valores siempre serán diferentes
        // Si generamos el password sin salt, basándonos solo en el password (que es solo un texto plano) los hashes generados basados en ese password siempre serán iguales
        // El salt se debe guardar junto al password para contrastar el login

        // Método para generar el salt
        public ResultadoHash Hash(string textoPlano)
        {
            // Generamos el salt aleatorio
            var salt = new byte[16];
            using (var random = RandomNumberGenerator.Create())
            {
                random.GetBytes(salt); // Genera un array aleatorio de bytes
            }

            // Llamamos al método ResultadoHash y retornamos el hash con el salt
            return Hash(textoPlano, salt);
        }


        public ResultadoHash Hash(string textoPlano, byte[] salt)
        {
            //Pbkdf2 es un algoritmo de encriptación
            var claveDerivada = KeyDerivation.Pbkdf2(password: textoPlano,
                salt: salt, prf: KeyDerivationPrf.HMACSHA1,
                iterationCount: 10000,
                numBytesRequested: 32);

            var hash = Convert.ToBase64String(claveDerivada);

            return new ResultadoHash()
            {
                Hash = hash,
                Salt = salt
            };
        }
    }

El servicio hay que registrarlo en el program

builder.Services.AddTransient<HashService>();

Y luego, en el controller, empleamos el servicio para crear un usuario y ver si existe
 private readonly AlmacenContext context;
        private readonly IConfiguration configuration;
        private readonly IHashService hashService;
        private readonly AlmacenContext context;
        private readonly IDataProtector dataProtector;
        public UsuariosController(AlmacenContext context, IConfiguration configuration, IDataProtectionProvider dataProtectionProvider, IHashService hashService)
        {
            this.context = context;
            this.configuration = configuration;
            this.hashService = hashService;
            dataProtector = dataProtectionProvider.CreateProtector(configuration["ClaveEncriptacion"]);
        }
...

[HttpPost("hash/nuevousuario")]
        public async Task<ActionResult> PostNuevoUsuarioHash([FromBody] DTOUsuario usuario)
        {
            var resultadoHash = hashService.Hash(usuario.Password);
            var newUsuario = new Usuario
            {
                Email = usuario.Email,
                Password = resultadoHash.Hash,
                Salt = resultadoHash.Salt
            };

            await context.Usuarios.AddAsync(newUsuario);
            await context.SaveChangesAsync();

            return Ok(newUsuario);
        }

        [HttpPost("hash/checkusuario")]
        public async Task<ActionResult> CheckUsuarioHash([FromBody] DTOUsuario usuario)
        {
            var usuarioDB = await context.Usuarios.FirstOrDefaultAsync(x => x.Email == usuario.Email);
            if (usuarioDB == null)
            {
                return Unauthorized();
            }

            var resultadoHash = hashService.Hash(usuario.Password,usuarioDB.Salt);
            if (usuarioDB.Password == resultadoHash.Hash)
            {
                return Ok();
            }
            else
            {
                return Unauthorized();
            }

        }


---------------------------------------------------------------------------------------------
JWT

Para devolver un token de acceso a los usuarios autenticados, establecemos una clave de firma en la configuración del proyecto:

 "ClaveJWT": "Curso@.net#2024_Talio"

Creamos una clase para manejar la información que devolveremos al usuario autenticado (DTOLoginResponse)
Y en un punto de acceso del controller de usuarios gestionamos el login

  [HttpPost("login")]
        public async Task<ActionResult> Login([FromBody] DTOUsuario usuario)
        {
            var usuarioDB = await context.Usuarios.FirstOrDefaultAsync(x => x.Email == usuario.Email);
            if (usuarioDB == null)
            {
                return BadRequest();
            }

            var resultadoHash = hashService.Hash(usuario.Password, usuarioDB.Salt);
            if (usuarioDB.Password == resultadoHash.Hash)
            {
                var response = GenerarToken(usuario);
                return Ok(response);
            }
            else
            {
                return BadRequest();
            }
        }

        [Authorize(AuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)]
        [HttpPost("renovartoken")]
        public async Task<ActionResult> RenovarToken([FromBody] DTOUsuario usuario)
        {
            var usuarioDB = await context.Usuarios.FirstOrDefaultAsync(x => x.Email == usuario.Email);
            if (usuarioDB == null)
            {
                return BadRequest();
            }

            var response = GenerarToken(usuario);
            return Ok(response);
        }

        private DTOLoginResponse GenerarToken(DTOUsuario credencialesUsuario)
        {
            var claims = new List<Claim>()
            {
                new Claim(ClaimTypes.Email, credencialesUsuario.Email),
                new Claim("lo que yo quiera", "cualquier otro valor")
            };

            var clave = configuration["ClaveJWT"];
            var claveKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(clave));
            var signinCredentials = new SigningCredentials(claveKey, SecurityAlgorithms.HmacSha256);

            var securityToken = new JwtSecurityToken(
                claims: claims,
                expires:DateTime.Now.AddDays(30),
                signingCredentials: signinCredentials
            );

            
            var tokenString = new JwtSecurityTokenHandler().WriteToken(securityToken);

            return new DTOLoginResponse()
            {
                Token = tokenString,
                Email = credencialesUsuario.Email
            };
        }

Configuramos la autenticación en el Program

builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
               .AddJwtBearer(options => options.TokenValidationParameters = new TokenValidationParameters
               {
                   ValidateIssuer = false,
                   ValidateAudience = false,
                   ValidateLifetime = true,
                   ValidateIssuerSigningKey = true,
                   IssuerSigningKey = new SymmetricSecurityKey(
                     Encoding.UTF8.GetBytes(builder.Configuration["ClaveJWT"]))
               });


builder.Services.AddSwaggerGen(c =>
{
    c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
    {
        Name = "Authorization",
        Type = SecuritySchemeType.ApiKey,
        Scheme = "Bearer",
        BearerFormat = "JWT",
        In = ParameterLocation.Header
    });

    c.AddSecurityRequirement(new OpenApiSecurityRequirement
                {
                    {
                        new OpenApiSecurityScheme
                        {
                            Reference = new OpenApiReference
                            {
                                Type = ReferenceType.SecurityScheme,
                                Id = "Bearer"
                            }
                        },
                        new string[]{}
                    }
                });

});

Incluimos la anotación Authorize en el controller que queramos o en los métodos
También podemos habilitar algún método con [AllowAnonymous]

Desde Swagger, debemos ver un botón verde Authorize para poder incluir un token. 
Al darle, ponemos Bearer y después pegamos el token



---------------------------------------------------------------------------------------------
Serilog

Instalamos estos paquetes. A día de hoy el paquete Serilog.Sinks.MSSqlServer en su versión 6.6.1

Serilog.AspNetCore
Serilog.Settings.Configuration
Serilog.Sinks.MSSqlServer

Agregamos en el app.settings.Development la configuración de serilog

 "Serilog": {
    "MinimumLevel": "Information",
    "WriteTo": [
      {
        "Name": "MSSqlServer",
        "Args": {
          "connectionString": "Data Source=localhost;Initial Catalog=MiAlmacen;Integrated Security=True;TrustServerCertificate=true",
          "tableName": "Logs",
          "autoCreateSqlTable": true
        }
      }
    ]
  }

  Y en el Program registramos serilog para que de forma automática vaya anotando la actividad.
  En este caso, el nivel de log es information y lo guardará en una tabla Logs de nuestra base de datos
  Los diferentes niveles de log son: Critical, Error, Warning, Information, Debug y Trace

----------------------------------------------------------------------------------------------
Logs

Mediante ILogger podemos hacer que un controller emita mensajes personalizados
Hay que inyectar la dependencia en el controller y luego registrar los mensajes de log allá donde queramos,
por ejemplo así:

  logger.LogInformation(usuario.Email + " ha iniciado un login el día " +
    DateTime.Now);  

----------------------------------------------------------------------------------------------
ANGULAR

Creamos proyecto Angular, instalamos dependencias

ng new AngularAlmacen 

npm install bootstrap 
npm install primeng@16.4.4 
npm install primeicons

En el archivo angular.json integramos estilos y scripts de primeng y bootstrap

"styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css",
              "node_modules/primeng/resources/themes/lara-light-blue/theme.css",
              "node_modules/primeng/resources/primeng.min.css",
              "node_modules/primeicons/primeicons.css"
            ],
            "scripts": [
              "node_modules/bootstrap/dist/js/bootstrap.bundle.min.js"
            ]


Creamos módulos y componentes para la aplicación

ng g m inicio

ng g c inicio/login --skip-tests=true
ng g c inicio/notFound --skip-tests=true
ng g m almacen
ng g c almacen/almacen -s --flat --skip-tests=true
ng g c almacen/categorias --skip-tests=true
ng g c almacen/productos --skip-tests=true
ng g s almacen/almacen --skip-tests=true

Creamos archivo de rutas app-routing.module.ts

import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { LoginComponent } from './inicio/login/login.component';
import { NotFoundComponent } from './inicio/not-found/not-found.component';

const appRoutes: Routes = [
  { path: '', redirectTo: '/login', pathMatch: 'full' },
  { path: 'login', component: LoginComponent },
  {
    path: 'almacen',
    loadChildren: () => import('./almacen/almacen.module').then((m) => m.AlmacenModule)
  },
  { path: '**', component: NotFoundComponent }
];

@NgModule({
  imports: [RouterModule.forRoot(appRoutes)],
  exports: [RouterModule]
})
export class AppRoutingModule {}

Creamos el enrutamiento para el módulo de almacén
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { CategoriasComponent } from './categorias/categorias.component';
import { ProductosComponent } from './productos/productos.component';
import { AlmacenComponent } from './almacen.component';

const appRoutes: Routes = [
  {
    path: '',
    component: AlmacenComponent,
    children: [
      { path: '', redirectTo: '/almacen/categorias', pathMatch: 'full' },
      { path: 'categorias', component: CategoriasComponent },
      { path: 'productos', component: ProductosComponent }
    ]
  }
];

@NgModule({
  imports: [RouterModule.forChild(appRoutes)],
  exports: [RouterModule]
})
export class AlmacenRoutingModule {}


Cambiamos el módulo almacén

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { CategoriasComponent } from './categorias/categorias.component';
import { ProductosComponent } from './productos/productos.component';
import { AlmacenComponent } from './almacen.component';
import { AlmacenService } from './almacen.service';
import { AlmacenRoutingModule } from './almacen-routing.module';

@NgModule({
  declarations: [CategoriasComponent, ProductosComponent, AlmacenComponent],
  imports: [CommonModule, AlmacenRoutingModule],
  providers: [AlmacenService]
})
export class AlmacenModule {}

Cambiamos el app.component.html

<h1>Gestión almacén</h1>
<hr/>
<router-outlet></router-outlet>

Cambiamos el almacen.component.html

<h1>Gestión almacén</h1>
<hr/>
<router-outlet></router-outlet>

Cambiamos el módulo principal app.module para incluir el sistema de rutas y el módulo HttpClientModule

import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';

import { AppComponent } from './app.component';
import { AppRoutingModule } from './app-routing.module';
import { HttpClientModule } from '@angular/common/http';

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule, BrowserAnimationsModule, HttpClientModule, AppRoutingModule],
  bootstrap: [AppComponent]
})
export class AppModule {}

Cambiamos el html y el css del not-found.component

 <div class="row">
  <div class="col">
    <img src="https://www.seekahost.com/wp-content/uploads/2017/11/404-page-not-found.jpg" class="img-fluid" />
  </div>
</div>

img {
  height: 100%;
  width: 100%;
}




